如何一步一步的启动引导内核
首先有两个概念  两种模式  一种是自动加载模式  也是用户的模式
	另外一种是下载模式  也是开发模式  是开发人员使用的模式 对于用户来说  他用的只是自主模式也是用户的模式。
UBOOT的启动流程下面我们来一起分析一下
	首先必须要找到他的第一条执行的代码  他是没有main函数的  uboot  的头在哪里  需要找到他的头文件   是每个板子配置的头文件 是在uboot源码里面的/board/smdk2440/uboot.lds文件 文件可能看不懂 但是要找到两个信息  我们要找到uboot 的入口在哪里ENTRY(_start)在/cpu/arm920t。。。找到一个标号_start这个入口就是我们要找的头 
	第一个阶段
  上电之后 b reset 到这个reset这个标号去看 一次就是看第一阶段他的内部初始化
cpu模式 关看门狗 禁止中断 代码复制 配置内存控制 配置堆栈空间 进入C代码
	看门狗 监控系统运行的状态  如果没有喂狗  系统就是自动重启  如果你没有关闭看门狗 那么你就会出现一个问题就是 还没有启动成功就又重新启动了
	进入第二个阶段
也就是进入到C语言的阶段
	就是PC指针赋值  这个值是指向一个C函数的的  有一个函数是start_armboot(void)里面有个for循环  这个是干什么的呢？ 里面有一个数组  里面放的都是函数指针一个循环就把所有的初始化的 函数执行一遍  剩下的还有的单独初始后  最后进入一个死循环 for{;;}  我们可以感受一下  因为  进入到uboot中 他是始终等待用户命令输入的状态
  在汇编的那一段代码 里面都是与硬件相关的 有完成的注释 就是都是英文的 对照芯片手册  对你的思维会有一个很大的提高
以上是启动流程  这里选出了两个命令  一个是go命令 一个是bootm命令  可以仔细的看一下他们的实现代码 可以读的懂的
	先看一下go命令的实现  int argc  参数的个数 go命令至少需要另个参数  一个是go  一个是地址
	addr = simple_strtoul(argv[1], NULL,16)
	对于上面的这个我们怎么解释呢,看了我也没有太明白   函数名也是一个地址  知道了这个地址我们就可以运行这个程序  
	bootm   这个命令的实现 int do_bootm(..)就是这个混蛋函数  分析一下  bootm  在用的时候可以不用携带参数 在执行的时候他会检查有没有这个头部 如果有就会继续进入解压缩的工作因为 uImage就是一个压缩的文件  所以必须要进入这个解压多的工作 uImage是什么格式的  是自解压的程序  但是也是压缩的程序  在uboot里面  他被认为是没有压缩的 因为他可以自己解压阿   这里呢  通过一个switch  里面会查看你是什么样的系统 因为uboot 支持了很多的uboot 的系统和架构

